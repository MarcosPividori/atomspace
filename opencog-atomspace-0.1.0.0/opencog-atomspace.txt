-- Hoogle documentation, generated by Haddock
-- See Hoogle, http://www.haskell.org/hoogle/


-- | -
--   
--   <ul>
--   <li></li>
--   </ul>
@package opencog-atomspace
@version 0.1.0.0


-- | This library defines Haskell Bindings for the AtomSpace.
module OpenCog.AtomSpace

-- | Main Data Type for representing programs working on an AtomSpace. We
--   have to use the IO monad because of the use of FFI for calling c
--   functions for working on a mutable instance of the atomspace, so we
--   have side effects.
data AtomSpace a

-- | <a>AtomSpaceObj</a> is a specific AtomSpace instance.
data AtomSpaceObj

-- | <a>getParent</a> given an AtomSpace instance returns the parent
--   AtomSpace.
getParent :: AtomSpaceObj -> Maybe AtomSpaceObj

-- | <a>newAtomSpace</a> creates a new Atomspace, from a optionally given
--   parent atomspace.
newAtomSpace :: Maybe AtomSpaceObj -> IO AtomSpaceObj

-- | <a>onAtomSpace</a> runs the specified computation on the atomspace
--   instance provided.
onAtomSpace :: AtomSpaceObj -> AtomSpace a -> IO a

-- | Syntactic sugar for calling the function <a>onAtomSpace</a>. For
--   example, we can write code like this: a &lt;- newAtomSpace b &lt;-
--   newAtomSpace
--   
--   a &lt;: insert (ConceptNode "concept1" noTv) a &lt;: debug b &lt;:
--   remove (PredicateNode "predicate1" (stv 1 1))
(<:) :: AtomSpaceObj -> AtomSpace a -> IO a

-- | <a>runOnNewAtomSpace</a> creates a new AtomSpace (C++ object) and does
--   some computation over it.
runOnNewAtomSpace :: AtomSpace a -> IO a

-- | <a>insert</a> creates a new atom on the atomspace or updates the
--   existing one.
insert :: Typeable a => Atom a -> AtomSpace ()

-- | <a>remove</a> deletes an atom from the atomspace. Returns True in
--   success or False if it couldn't locate the specified atom.
remove :: Typeable a => Atom a -> AtomSpace Bool

-- | <a>get</a> looks for an atom in the atomspace and returns it. (With
--   updated mutable information)
get :: a <~ AtomT => Atom a -> AtomSpace (Maybe (Atom a))

-- | <a>debug</a> prints the state of the AtomSpace on stderr. (only for
--   debugging purposes)
debug :: AtomSpace ()

-- | <a>cogBind</a> calls the pattern matcher with the given bindLink. (you
--   should insert the bindlink to the atomspace before using this
--   function).
cogBind :: Atom BindT -> AtomSpace (Maybe AtomGen)

-- | <a>printAtom</a> prints the given atom on stdout.
printAtom :: Typeable a => Atom a -> IO ()

-- | <a>showAtom</a> shows an atom in opencog notation (indented notation).
showAtom :: Typeable a => Atom a -> String

-- | <a>TruthVal</a> represent the different types of TruthValues.
data TruthVal
SimpleTV :: Double -> Double -> TruthVal
tvMean :: TruthVal -> Double
tvConfidence :: TruthVal -> Double
CountTV :: Double -> Double -> Double -> TruthVal
tvMean :: TruthVal -> Double
tvCount :: TruthVal -> Double
tvConfidence :: TruthVal -> Double
IndefTV :: Double -> Double -> Double -> Double -> Double -> TruthVal
tvMean :: TruthVal -> Double
tvL :: TruthVal -> Double
tvU :: TruthVal -> Double
tvConfLevel :: TruthVal -> Double
tvDiff :: TruthVal -> Double
FuzzyTV :: Double -> Double -> TruthVal
tvMean :: TruthVal -> Double
tvConfidence :: TruthVal -> Double
ProbTV :: Double -> Double -> Double -> TruthVal
tvMean :: TruthVal -> Double
tvCount :: TruthVal -> Double
tvConfidence :: TruthVal -> Double

-- | Atom name type.
type AtomName = String

-- | <a>Atom</a> is the main data type to represent the different types of
--   atoms.
--   
--   Here we impose type constraints in how atoms relate between them.
--   
--   The <tt>&lt;~</tt> type operator means that the type on the left
--   "inherits" from the type on the right.
--   
--   DEFINING NEW ATOM TYPES:
--   
--   If it is a node: We add a new data constructor such as:
--   NewAtomTypeNode :: AtomName -&gt; TVal -&gt; Atom NewAtomTypeT where
--   NewAtomTypeT is a phantom type (automatically generated by temp.
--   hask.).
--   
--   If it is a link: If it is of a fixed arity: We impose the type
--   constraints on each of the members of its outgoing set.
--   NewAtomTypeLink :: (a <a>t1,b &lt;~ t2,c &lt;~ t3) =</a> TVal -&gt;
--   Atom a -&gt; Atom b -&gt; Atom c -&gt; Atom NewAtomTypeT
--   
--   If it is of unlimited arity: We define it as a data constructor that
--   takes a list of atoms as first argument. All of the members of its
--   outgoing set will satisfy the same constraints. For example suppose
--   NewAtomTypeLink accepts nodes that are concepts: NewAtomTypeLink ::
--   TVal -&gt; [Gen ConceptT] -&gt; Atom NewAtomTypeT
--   
--   Also, you have to modify the module Internal. Adding proper case
--   clauses for this new atom type to the functions "toRaw" and "fromRaw".
data Atom (a :: AtomType)
PredicateNode :: AtomName -> TVal -> Atom PredicateT
AndLink :: TVal -> [AtomGen] -> Atom AndT
OrLink :: TVal -> [AtomGen] -> Atom OrT
ImplicationLink :: TVal -> Atom a -> Atom b -> Atom ImplicationT
EquivalenceLink :: TVal -> Atom a -> Atom b -> Atom EquivalenceT
EvaluationLink :: TVal -> Atom p -> Atom l -> Atom EvaluationT
ConceptNode :: AtomName -> TVal -> Atom ConceptT
InheritanceLink :: TVal -> Atom c1 -> Atom c2 -> Atom InheritanceT
SimilarityLink :: TVal -> Atom c1 -> Atom c2 -> Atom SimilarityT
MemberLink :: TVal -> Atom c1 -> Atom c2 -> Atom MemberT
SatisfyingSetLink :: Atom p -> Atom SatisfyingSetT
NumberNode :: Double -> Atom NumberT
ListLink :: [AtomGen] -> Atom ListT
SetLink :: [AtomGen] -> Atom SetT
SchemaNode :: AtomName -> Atom SchemaT
GroundedSchemaNode :: AtomName -> Atom GroundedSchemaT
ExecutionLink :: Atom s -> Atom l -> Atom a -> Atom ExecutionT
VariableNode :: AtomName -> Atom VariableT
VariableList :: [Gen VariableT] -> Atom VariableT
SatisfactionLink :: Atom v -> Atom l -> Atom SatisfactionT
ForAllLink :: TVal -> Atom v -> Atom i -> Atom ForAllT
AverageLink :: TVal -> Atom v -> Atom a -> Atom AverageT
QuoteLink :: Atom a -> Atom a
BindLink :: Atom v -> Atom p -> Atom q -> Atom BindT

-- | <a>Gen</a> groups all the atoms that are children of the atom type a.
data Gen a
Gen :: Atom b -> Gen a

-- | <a>appGen</a> evaluates a given function with the atom type instance
--   wrapped inside the <a>Gen</a> type.
appGen :: (forall b. (Typeable a, b <~ a) => Atom b -> c) -> Gen a -> c

-- | <a>AtomGen</a> is a general atom type hiding the type variables.
--   (necessary when working with many instances of different atoms, for
--   example, for lists of general atoms)
type AtomGen = Gen AtomT
stv :: Double -> Double -> Maybe TruthVal
ctv :: Double -> Double -> Double -> Maybe TruthVal
itv :: Double -> Double -> Double -> Double -> Double -> Maybe TruthVal
ftv :: Double -> Double -> Maybe TruthVal
ptv :: Double -> Double -> Double -> Maybe TruthVal

-- | TruthVal syntactic sugar.
noTv :: Maybe TruthVal

-- | <a>atomList</a> is simple sugar notation for listing atoms, using
--   operators <a>|&gt;</a> and <a>\&gt;</a>. For example, if you want to
--   define a list of atoms: l :: [AtomGen] l = atomList |&gt; ConceptNode
--   "concept1" noTv |&gt; PredicateNode "predicate2" noTv &gt; ConceptNode
--   "lastconcept" noTv
atomList :: Typeable c => ([Gen c] -> [Gen c])

-- | <a>|&gt;</a> and <a>\&gt;</a> operators are provided for easier
--   notation of list of <a>Gen</a> elements when working with atoms of
--   random arity (e.g. <a>ListLink</a>).
(|>) :: (Typeable c, b <~ c) => ([Gen c] -> a) -> Atom b -> ([Gen c] -> a)
(\>) :: (Typeable c, b <~ c) => ([Gen c] -> a) -> Atom b -> a
data AtomType
AbsentT :: AtomType
AnchorT :: AtomType
AndT :: AtomType
ArithmeticT :: AtomType
AssignT :: AtomType
AssociativeT :: AtomType
AtomT :: AtomType
AttractionT :: AtomType
AverageT :: AtomType
BindT :: AtomType
ChoiceT :: AtomType
ConceptT :: AtomType
ContextT :: AtomType
DefineT :: AtomType
DefinedRelationshipT :: AtomType
DeleteT :: AtomType
EqualT :: AtomType
EquivalenceT :: AtomType
EvaluationT :: AtomType
ExecutionT :: AtomType
ExecutionOutputT :: AtomType
ExistsT :: AtomType
ExtensionalSimilarityT :: AtomType
FoldT :: AtomType
ForAllT :: AtomType
FreeT :: AtomType
FunctionT :: AtomType
GetT :: AtomType
GreaterThanT :: AtomType
GroundedPredicateT :: AtomType
GroundedProcedureT :: AtomType
GroundedSchemaT :: AtomType
ImplicationT :: AtomType
InheritanceT :: AtomType
InsertT :: AtomType
IntensionalInheritanceT :: AtomType
IntensionalSimilarityT :: AtomType
LambdaT :: AtomType
LinkT :: AtomType
ListT :: AtomType
MemberT :: AtomType
NodeT :: AtomType
NotT :: AtomType
NotypeT :: AtomType
NumberT :: AtomType
OrT :: AtomType
OrderedT :: AtomType
PatternT :: AtomType
PlusT :: AtomType
PredicateT :: AtomType
ProcedureT :: AtomType
PutT :: AtomType
QuantityT :: AtomType
QuoteT :: AtomType
RemoveT :: AtomType
SatisfactionT :: AtomType
SatisfyingSetT :: AtomType
SchemaEvaluationT :: AtomType
SchemaExecutionT :: AtomType
SchemaT :: AtomType
ScholemT :: AtomType
SequentialAndT :: AtomType
SetT :: AtomType
SimilarityT :: AtomType
SubsetT :: AtomType
TimesT :: AtomType
TypeChoiceT :: AtomType
TypeT :: AtomType
TypedVariableT :: AtomType
UnorderedT :: AtomType
VariableListT :: AtomType
VariableT :: AtomType
VirtualT :: AtomType

-- | <tt>&lt;~</tt> builds a list of constraints to assert that all the
--   ancestors of b (included b itself) are ancestors of a.
type (<~) a b = (Typeable a, ParConst a (Up b))
